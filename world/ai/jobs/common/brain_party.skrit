/*
  ============================================================================
  ----------------------------------------------------------------------------

	File		: 	brain_party.skrit

	Author(s)	: 	Eric Tams, Bartosz Kijanka

	Purpose		:	Coordinates the collective automatic behavior of a party.


	Expected Behavior: (out of date)
	------------------

		The party brain will execute periodically ( every sensor scan period ) seconds
		and try to take action.  The party brain will try to take action only with party
		members who are NOT already 'busy' AND who have permissions set which allow
		them to take automatic actions.  The party beain operates in two passes:
		Defensive and Offensive.  Currently the brain favors Defensive.  Meaning; the
		brain will always try to perform a Defensive action before an Offensive one.
		If the brain finds that it can't perform a Defensive action, it will try to
		take Offensive action.


	The Defensive pass:

		Find a party member with the lowest life.  Find an idle party party member
		with the with the most mana and best healing spell and who has permission
		to heal others, and have him cast it on the weak guy.

		If nobody is low on life, proceed to find a party member with low mana.  Then
		find an idle party member who has a mana xfer spell and has permission to
		auto-use it.  Cast it on the weak guy.


	Offensive pass:

		Find a party member who is currently least likely to survive the near future, based
		on the enemies that have engaged him.  If there are any idle members, take the 
		toughest one and have him attack the toughest attacker of the weak guy.


	Current permissions the party brain looks at are:

		Mind.ActorAutoHealsOthersLife
		Mind.ActorAutoXfersMana
		Mind.ActorAutoDefendsOthers


	(C)opyright 2001 Gas Powered Games, Inc.

  ----------------------------------------------------------------------------
  ============================================================================
*/

Go		m_Go$;
GoMind	m_Mind$;
GoParty m_Party$;
Job		m_Job$;

property	int		min_party_size$			= 2			doc = "How many friends must be nearby to form a party";
property	int		max_party_size$			= 8			doc = "What is the larget size I will leat a party be to join, or add into my own.?";

property	float	heal$					= 0.30		doc = "What ratio of the time will the party try to heal members";
property	int		heal_charges$			= 2			doc	= "How many times the party can heal before it must recharge";
property	float	heal_recharge$			= 15.00		doc = "Seconds before the party will try to heal members";
property	bool	heal_by_range$ 			= false		doc = "Use range to determine who will heal instead of who is the best helper.";

property	float	reanimate$				= 0.30		doc = "What ratio of the time will the party try to re-animate dead members";
property	int		reanimate_charges$		= 2			doc	= "How many times the party can re-animate before it must recharge";
property	float	reanimate_recharge$		= 15.00		doc = "Seconds before the party will try to re-animate dead members";

property	float	formation_change$		= 0.02		doc	= "Chance to change the formation shape each time it moves.";
property	int		formation_charges$		= 1			doc	= "How many times the party can move in formation before it must recharge";
property	float	formation_recharge$		= 5.00		doc = "Seconds before the party will try to move in formation again";

property	float	approach_distance$		= 1.66		doc = "Meters to try to approach by when approaching in formation.";
property	float	min_approach_distance$		= 5.00		doc = "Minimum distance before the party will approach.";
property	float	melee_approach_distance$	= 3.00		doc = "Minimum distance before the party will approach.";

property	float	party_sight_distance$	= -1.0		doc	= "Set to a positive value to allow the party to see an enemy farther away (usefull for get friends) -1 to use sight range.";

property	bool	free_move_on_enemy_enter_ICZ$	 	= true 	doc = "if enemy enters ICZ allow party to freely attack";
property	bool	free_move_on_enemy_enter_OCZ$	 	= false	doc = "if enemy enters OCZ allow party to freely attack";
property	bool	free_move_on_life_low$	 			= false	doc = "if a party reaches life low allow party to freely attack";
property	bool	free_move_if_cant_respond$ 			= true 	doc = "allow characters to move freely if the can't attack back when in formation.";
property	bool	all_out_attack_if_cant_respond$ 	= true 	doc = "whole party will attack if they can't attack back when in formation.";

property	bool	move_ranged_in_formation$ 			= true 	doc = "move ranged attackers in formation even if they are allowed free movment.";
property	bool	move_melee_in_formation$ 			= true 	doc = "move melee attackers in formation even if they are closer then the min approach distance.";

property	bool	rank_members$ 						= true	doc = "assign party members rank so they can move in formation.";
property	bool	free_move$ 							= false doc = "allow free movement by default";
property	bool	use_loose_formation$ 				= false doc = "move in a disorganized formation (used for archers to prevent them from standing on each other)";
property	string	formation_list$ 							doc = "comma delimited list of possible formations to use (If empty will use default monster formations)";

property	int		required_party_members_to_hold_formation$		= 2 	doc = "Number of party members required to approach in formation.";
property	int		required_ranged_attackers_to_hold_formation$	= 1 	doc = "Number of ranged attackers required in the party to approach in formation.";
property	int		required_ranged_attackers_to_hold_ground$		= 9 	doc = "Number of ranged attackers required in the party to hold ground in formation.";
property	int		required_members_for_all_out_attack$			= -1	doc = "Mumber of party members required for an all out attack. (useful for getting friends or pack attacks.";		
property	int		required_alive_members_for_all_out_attack$		= -1	doc = "Mumber of alive party members required for an all out attack. (useful for getting friends or pack attacks.";

property	bool	flee_when_member_killed$						= false	doc = "Party members flee when a party member is killed.";

bool 	party_dirty$ = true;
bool	move_freely$ = false;
bool	melee_ranked$ = false;
bool	in_combat$ = false;

int		heal_charges_used$ = 0;
int		reanimate_charges_used$ = 0;
int		formation_charges_used$ = 0;
int  	num_ranged_attackers_in_party$ = 0;
int  	num_alive_members_in_party$ = 0;
int		num_memebers$ = 0;
int		num_ranked$ = 0;

#include "k_job_c_attack_utils"


startup state STARTUP$
{
}

////////////////////////////////////////////////////////////////////////////////
//	init
event OnJobInitPointers$( Job job$ )
{
	m_Job$		= job$;
	m_Go$		= job$.Go;
	m_Mind$		= job$.Go.Mind;
	m_Party$	= job$.Go.Party;	
}


event OnJobInit$( Job job$ )
{
	OnJobInitPointers$( job$ );

	SetState Thinking$;
}


////////////////////////////////////////////////////////////////////////////////
//	helper functions

////////////////////////////////////////
//	function GetToughestEnemy

Go GetToughestEnemy$( Go member$ )
{
	Go toughestEnemy$;
	
	if( party_sight_distance$ > 0 )
	{
		m_Mind$.TempGopColl1.Clear;
		m_Mind$.TempGopColl2.Clear;
		
		AIQuery.GetOccupantsInSphere( member$.placement.position, party_sight_distance$, m_Mind$.TempGopColl1 );
		
		m_Mind$.TempQtColl1.Clear;
		m_Mind$.TempQtColl1.Add( QT_ENEMY );
		m_Mind$.TempQtColl1.Add( QT_ALIVE_CONSCIOUS );
		m_Mind$.TempQtColl1.Add( QT_ATTACKABLE );
	
		AIQuery.Get( member$, m_Mind$.TempQtColl1, m_Mind$.TempGopColl1, m_Mind$.TempGopColl2 );
		toughestEnemy$ = AIQuery.GetMax( member$, QT_OFFENSE_FACTOR, m_Mind$.TempGopColl2 ); 
	} 
	
	if( toughestEnemy$ == NULL )
	{
		toughestEnemy$ = member$.mind.GetBestFocusEnemy();
	}
	
	return toughestEnemy$;
}

////////////////////////////////////////
//	function SelectFormation

void SelectFormation$( bool loose$, float change_chance$ )
{
	if ( num_ranked$ == 0 )
	{
		return;
	}
	if( loose$ ) {
		int formation$ = Math.RandomInt( 2 );
		if( formation$ == 0 )
		{
			m_Go$.Party.Formation.Shape = "monster_blob_1";
		}
		else if( formation$ == 1 )
		{
			m_Go$.Party.Formation.Shape = "monster_blob_2";
		}
		else if( formation$ == 2 )
		{
			m_Go$.Party.Formation.Shape = "monster_blob_3";
		}
	} else if( change_chance$ > Math.RandomFloat( 1 ) )	{
		if( StringTool.IsEmpty( formation_list$ ) )
		{
			int formation$ = Math.RandomInt( 4 );
			if( formation$ == 0 )
			{
				m_Go$.Party.Formation.Shape = "monster_1";
			}
			else if( formation$ == 1 )
			{
				m_Go$.Party.Formation.Shape = "monster_2";
			}
			else if( formation$ == 2 )
			{
				m_Go$.Party.Formation.Shape = "monster_3";
			}
			else if( formation$ == 3 )
			{
				m_Go$.Party.Formation.Shape = "monster_4";
			}
			else
			{
				m_Go$.Party.Formation.Shape = "double_column";
			}
		} 
		else 
		{
			int formation$ = Math.RandomInt( StringTool.GetNumDelimitedValues( formation_list$ ) - 1 );
			string temp$ = StringTool.GetDelimitedString( formation_list$, formation$ );
			if( !StringTool.IsEmpty( temp$ ) )
			{
				m_Go$.Party.Formation.Shape = StringTool.GetDelimitedString( formation_list$, formation$ );
			}
			else
			{
				m_Go$.Party.Formation.Shape = "monster_1";
			}
		}
	}
}


////////////////////////////////////////
//	function RankMelee

void RankMelee$( )
{
	if( !rank_members$ )
	{
		return;
	}
	melee_ranked$ = true;
	
	num_ranked$ = 0;
	int i$ = 0;
	int iend$ = m_Go$.Children.Size();
	int rank$ = 0;
	Go temp_child$;
	
	while( i$ != iend$ )
	{
		temp_child$ = m_Go$.Children.Get( i$ );
		if( AIQuery.Is( m_Go$, temp_child$, QT_ALIVE_CONSCIOUS ) && !( temp_child$.Inventory.IsRangedWeaponSelected || temp_child$.Inventory.IsSpellSelected ) )
		{
			num_ranged_attackers_in_party$ += 1;
			temp_child$.Mind.Rank = rank$;
			rank$ += 1;
		} else {
			temp_child$.Mind.Rank = 0xFFFFFFFF;
			temp_child$.Mind.RSSetCombatOrders( CO_FREE );
			temp_child$.Mind.RSSetMovementOrders( MO_FREE );
		}
		i$ += 1;   
	}
	num_ranked$ = rank$;
}


////////////////////////////////////////
//	function FreeMovement

void FreeMovement$( )
{
	if( !rank_members$ )
	{
		return;
	}
		
	move_freely$ = true;
	num_ranked$ = 0;
					
	int i$ = 0;
	int iend$ = m_Go$.Children.Size();
	while( i$ != iend$ )
	{
		m_Go$.Children.Get( i$ ).Mind.RSSetCombatOrders( CO_FREE );
		m_Go$.Children.Get( i$ ).Mind.RSSetMovementOrders( MO_FREE );
		
		i$ += 1;   
	}
	
	if( move_ranged_in_formation$ && ( num_alive_members_in_party$ >= required_party_members_to_hold_formation$ ) )
	{
		num_ranged_attackers_in_party$ = 0;
		int i$ = 0;
		int iend$ = m_Go$.Children.Size();
		int rank$ = 0;
		Go temp_child$;
		
		while( i$ != iend$ )
		{
			temp_child$ = m_Go$.Children.Get( i$ );
			if( AIQuery.Is( m_Go$, temp_child$, QT_ALIVE_CONSCIOUS ) && ( temp_child$.Inventory.IsRangedWeaponSelected || temp_child$.Inventory.IsSpellSelected ) )
			{
				num_ranged_attackers_in_party$ += 1;
				temp_child$.Mind.Rank = rank$;
				rank$ += 1;
			} else {
				temp_child$.Mind.Rank = 0xFFFFFFFF;
			}
			i$ += 1;   
		}
		num_ranked$ = rank$;
	}
	
	SelectFormation$( use_loose_formation$, 0 );
}


////////////////////////////////////////
//	function InitParty

void InitParty$( )
{
	m_Party$.TempGopCollA.Clear;
	
	// get alive party members
	if( !AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find alive members\n",m_Go$.TemplateName );
	}
	
	if( free_move$ || move_freely$ )
	{
		FreeMovement$();
		return;
	}
	
	if( melee_ranked$ )
	{
		RankMelee$();
		return;
	}
	
	num_alive_members_in_party$ = m_Party$.TempGopCollA.Size();
	num_ranged_attackers_in_party$ = 0;
	
	int i$ = 0;
	int iend$ = m_Go$.Children.Size();
	int rank$ = 0;
	Go temp_child$;
	
	// sort the members based on occupation.
	
	while( i$ != iend$ )
	{
		temp_child$ = m_Go$.Children.Get( i$ );
		if( AIQuery.Is( m_Go$, temp_child$, QT_ALIVE_CONSCIOUS ) && !temp_child$.Inventory.IsRangedWeaponSelected && !temp_child$.Inventory.IsSpellSelected )
		{
			temp_child$.Mind.Rank = rank$;
			
			report.reportf( "aiskrit", "'%s' -  ranked Melee actor to party\n",m_Go$.TemplateName );
			if(!move_freely$)
			{
				temp_child$.Mind.RSSetCombatOrders( CO_FREE );
				temp_child$.Mind.RSSetMovementOrders( MO_LIMITED );
			}
			rank$ += 1;
		}
		i$ += 1;   
	}
	
	i$ = 0;
	while( i$ != iend$ )
	{
		temp_child$ = m_Go$.Children.Get( i$ );
		if ( AIQuery.Is( m_Go$, temp_child$, QT_ALIVE_CONSCIOUS ) && temp_child$.Inventory.IsRangedWeaponSelected )
		{
			num_ranged_attackers_in_party$ += 1;
			temp_child$.Mind.Rank = rank$;
			
			report.reportf( "aiskrit", "'%s' -  ranked Ranged actor to party\n",m_Go$.TemplateName );
			if(!move_freely$)
			{
				temp_child$.Mind.RSSetCombatOrders( CO_FREE );
				temp_child$.Mind.RSSetMovementOrders( MO_HOLD );
			}
			
			rank$ += 1;
		}
		
		i$ += 1;   
	}
	
	i$ = 0;
	while( i$ != iend$ )
	{
		temp_child$ = m_Go$.Children.Get( i$ );
		if ( AIQuery.Is( m_Go$, temp_child$, QT_ALIVE_CONSCIOUS ) && temp_child$.Inventory.IsSpellSelected )
		{
			temp_child$.Mind.Rank = rank$;
			report.reportf( "aiskrit", "'%s' -  ranked Magic actor to party\n",m_Go$.TemplateName );
			
			if( AIQuery.Is( temp_child$, temp_child$.Inventory.SelectedSpell, QT_CASTABLE ) )
			{
				num_ranged_attackers_in_party$ += 1;
				
				if(!move_freely$)
				{
					temp_child$.Mind.RSSetCombatOrders( CO_FREE );
					temp_child$.Mind.RSSetMovementOrders( MO_HOLD );
				}
			} 
			else
			{
				if(!move_freely$)
				{
					temp_child$.Mind.RSSetCombatOrders( CO_FREE );
					temp_child$.Mind.RSSetMovementOrders( MO_LIMITED );
				}
			}
			
			rank$ += 1;
		}
		
		i$ += 1;   
	}
	
	i$ = 0;
	while( i$ != iend$ )
	{
		if ( !AIQuery.Is( m_Go$, m_Go$.Children.Get( i$ ), QT_ALIVE_CONSCIOUS ) )
		{
			m_Go$.Children.Get( i$ ).Mind.Rank = rank$;
			
			report.reportf( "aiskrit", "'%s' -  ranked Dead actor to party\n",m_Go$.TemplateName );
			rank$ += 1;
		}
		
		i$ += 1;   
	}
	
	num_ranked$ = rank$;
	
	if( num_ranked$ > 8 )
	{
		Report.Errorf("Mis-Calculation determining rank!! in %s\nRanked %d party members out of %d\n",m_Go$.TemplateName,rank$,iend$);
	}
	
	SelectFormation$( use_loose_formation$, 1 );
	
	report.reportf( "aiskrit", "'%s' -  Ranked %d party members out of %d\n",m_Go$.TemplateName,rank$,iend$ );		
	
	if( ( num_ranged_attackers_in_party$ < required_ranged_attackers_to_hold_formation$ ) || ( num_alive_members_in_party$ < required_party_members_to_hold_formation$ ) )
	{
		FreeMovement$();
	}
}

////////////////////////////////////////
//	function MoveFormation

void MoveFormation$( SiegePos position$ )
{
	SelectFormation$( use_loose_formation$, formation_change$ );   
	
	m_Go$.Party.Formation.Position = position$;
	m_Go$.Party.Formation.Move( QP_CLEAR, AO_PARTY, false);
}

////////////////////////////////////////
//	function TryResurrect
//	Use the party members specified to try to resurect a fallen friend

bool TryResurrect$( GopColl Resurrecting_members$ )
{
	report.reportf( "aiskrit", "'%s' - TryResurrect$ - entered\n", m_Go$.TemplateName );

	m_Party$.TempGopCollB.Clear();
	
	if( AIQuery.GetMin( m_Go$, QT_LIFE_LOW, m_Go$.Children, m_Party$.TempGopCollB ) )
	{
		report.reportf( "aiskrit", "'%s' -found weakest member to resurrect\n", m_Go$.TemplateName );
	
		////////////////////////////////////////////////////////////////////////////////
		//	help member with low LIFE
	
		////////////////////////////////////////
		//	find the weakest party member
		Go weakMember$ = m_Party$.TempGopCollB.Get( 0 );
	
		////////////////////////////////////////
		//	find if we need should resurrect

		// $$$ hacky shouldn't need to check visibility to see if a guy has gibbed
		
		if( ( weakMember$.aspect.lifestate == LS_DEAD_NORMAL ) && weakMember$.aspect.IsVisible ) 
		{
			report.reportf( "aiskrit", "'%s' -  weakest member is dead\n",m_Go$.TemplateName );
			
			////////////////////////////////////////
			//	find member to cast resurrect spell
			int i$ = 0;
			int iend$ = Resurrecting_members$.Size();
	
			Go helper$ 		= NULL;
			Go bestHelper$	= NULL;
			Go bestSpell$	= NULL;
			
			while( i$ != iend$ )
			{
				if( !m_Go$.Children.Get( i$ ).Mind.ActorAutoReanimatesFriends )
				{
					report.reportf( "aiskrit", "'%s' -  party member can't re-animate\n",m_Go$.TemplateName );
					i$ += 1;
					continue;
				} 
				
				report.reportf( "aiskrit", "'%s' -  party member can re-animate\n",m_Go$.TemplateName );
				
				helper$ = Resurrecting_members$.Get( i$ );
	
				float maxMana$ = -1;
				
				report.reportf( "aiskrit", "'%s' -  looking for spells to re-animate\n",m_Go$.TemplateName );
				
				////////////////////////////////////////
				//	get spells I can cast
				helper$.Mind.TempQtColl1.Clear;
				helper$.Mind.TempQtColl1.Add( QT_SPELL       );
				helper$.Mind.TempQtColl1.Add( QT_CASTABLE    );
				helper$.Mind.TempQtColl1.Add( QT_REANIMATING );
	
				////////////////////////////////////////
				//	reanimate dead buddies
				helper$.Mind.TempGopColl1.Clear;
				if( helper$.Mind.GetAutoItems( helper$.Mind.TempQtColl1, helper$.Mind.TempGopColl1 ) )
				{
					Go spell$ = helper$.Mind.TempGopColl1.Get( 0 );
	
					// $$$ IsSpellInProgress doesn't seem to work if the spell hasn't been cast yet... so caster may get stuck when
					// a new request to cast the spell comes in.
					
					if( !helper$.Inventory.IsSpellInProgress( spell$.TemplateName ) && HaveEnoughManaToCast$( helper$, spell$, weakMember$ ) )
					{
						if( maxMana$ < helper$.Aspect.CurrentMana )
						{
							maxMana$ 		= helper$.Aspect.CurrentMana;
							bestHelper$ 	= helper$;
							bestSpell$		= spell$;
						}
					}
				}
				i$ += 1;				
			}
	
			////////////////////////////////////////
			//	cast resurrect spell
			if( bestHelper$ != NULL )
			{
				Job temp_job$ = helper$.Mind.GetFrontJob( JQ_ACTION );
				bool doit$ = true;
				
				if( temp_job$ != NULL )
				{
					// make sure we aren't about to cast the resurrect spell
					
					Go current_spell$ = temp_job$.GoalModifier.Go;
					if( current_spell$ != NULL)
					{
						if( StringTool.SameNoCase(temp_job$.GoalModifier.Go.templatename, bestSpell$.TemplateName ) )
						{
							doit$ = false;
						}
					}
				}		
			
				if( doit$ )
				{
					bestHelper$.Mind.SDoJob( MakeJobReq( JAT_CAST, JQ_ACTION, QP_FRONT, AO_PARTY, weakMember$.Goid, bestSpell$.Goid ) );
					
					// set up the timer to decrement the resurrection charges.
					
					if( reanimate_recharge$ > 0.0 )
					{
						if( reanimate_charges_used$ == 0 )
						{
							This.CreateTimer( 1, reanimate_recharge$ );
							This.SetTimerGlobal( 1, true );
						}
						reanimate_charges_used$ += 1;
						This.SetTimerRepeatCount( 1, reanimate_charges_used$ ); 
					}
					return( true );
				}
			}
		}
	}
	return false;
}


////////////////////////////////////////////////////////////////////////////////
//	
//	function TryHeal$
//
//	Use the party members specified to try to heal a friend

bool TryHeal$( GopColl Healing_members$, Bool Heal_unconscious$ )
{
	report.reportf( "aiskrit", "'%s' - TryHeal$ - entered\n", m_Go$.TemplateName );

	////////////////////////////////////////////////////////////////////////////////
	//	find healing target

	m_Party$.TempGopCollB.Clear();

	m_Party$.TempQtColl1.Clear();
	m_Party$.TempQtColl1.Add( QT_ALIVE );
	m_Party$.TempQtColl1.Add( QT_LIFE_LOW );

	////////////////////////////////////////
	//	attempt early-out

	if( !AIQuery.GetMinN( m_Go$, m_Party$.TempQtColl1, 1, m_Go$.Children, m_Party$.TempGopCollB ) )
	{
		report.reportf( "aiskrit", "'%s' - exit - no members in need of healing\n", m_Go$.TemplateName );
		return false;
	}

	////////////////////////////////////////
	//	find weakest member

	int i$ = 0;
	int iend$ = m_Party$.TempGopCollB.Size();
	Go weakMember$ = NULL;

	while( ( i$ != iend$ ) && ( weakMember$ == NULL ) )
	{
		weakMember$ = m_Party$.TempGopCollB.Get( i$ );

		if( ( weakMember$.aspect.lifestate == LS_ALIVE_UNCONSCIOUS ) && Heal_unconscious$ )
		{
			if( m_Party$.TempGopCollB.Get( i$ ).Mind.AliveEnemiesVisible() )
			{
				weakMember$ = NULL;
			}
		}
		i$ += 1;
	}

	m_Party$.TempGopCollB.Clear();

	if( weakMember$ == NULL )
	{
		report.reportf( "aiskrit", "'%s' - exit - weakMember$ == NULL\n", m_Go$.TemplateName );
		return false;
	}

	report.reportf( "aiskrit", "'%s' - found member to heal = '%s'\n", m_Go$.TemplateName, weakMember$.TemplateName );

	////////////////////////////////////////////////////////////////////////////////
	//	find someone to cast heal on target

	i$		= 0;
	iend$ 	= Healing_members$.Size();

	Go helper$ 		= NULL;
	Go bestHelper$	= NULL;
	Go bestSpell$	= NULL;
	float smallRange$ = -1;          

	while( i$ != iend$ )
	{
		helper$ = Healing_members$.Get( i$ );

		if( !helper$.Mind.ActorAutoHealsOthersLife )
		{
			i$ += 1;
			continue;
		}
	
		helper$ = Healing_members$.Get( i$ );

		float maxHealing$ = -1;	

		////////////////////////////////////////
		//	find the most healing spell this guy can cast

		helper$.Mind.TempQtColl1.Clear();
		helper$.Mind.TempQtColl1.Add( QT_SPELL );
		helper$.Mind.TempQtColl1.Add( QT_CASTABLE );
		helper$.Mind.TempQtColl1.Add( QT_LIFE_HEALING );

		m_Party$.TempGopCollC.Clear;
		helper$.Mind.GetAutoItems( helper$.Mind.TempQtColl1, m_Party$.TempGopCollC );
		Go spell$ = AIQuery.GetMax( m_Go$, QT_LIFE_HEALING, m_Party$.TempGopCollC );

		////////////////////////////////////////
		//	compare spell and log if best one thus far

		if( spell$ != NULL )
		{
			if( heal_by_range$ )
			{
				float currentRange$ = AIQuery.GetDistance( weakMember$.Placement.Position, helper$.Placement.Position );
//				report.genericf("Range %g  Small Range %g\n", currentRange$, smallRange$);
				if( ( smallRange$ < 0.0 ) || ( smallRange$ > currentRange$ ) )
				{
					smallRange$		= currentRange$;
					bestHelper$ 	= helper$;
					bestSpell$		= spell$;
//					report.genericf("Switch Range %g  Small Range %g\n", currentRange$, smallRange$);
				}
			} 
			else
			{
				float currentHealing$ = AIQuery.GetTraitValue( m_Go$, spell$, QT_LIFE_HEALING );
				
				if( maxHealing$ < currentHealing$ )
				{
					maxHealing$ 	= currentHealing$;
					bestHelper$ 	= helper$;
					bestSpell$		= spell$;
				}
			}
		}
		i$ += 1;
	}

	////////////////////////////////////////
	//	cast healing spell

	if( bestHelper$ != NULL )
	{
		report.reportf( "aiskrit", "'%s' - found best helper to heal with = '%s'\n", m_Go$.TemplateName, bestHelper$.TemplateName );

		if ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER )
		{
			Job temp_job$ = helper$.Mind.GetFrontJob( JQ_ACTION );
			bool doit$ = true;
			
			if( temp_job$ != NULL )
			{
				// make sure we aren't about to cast the heal spell
				
				Go current_spell$ = temp_job$.GoalModifier.Go;
				if( current_spell$ != NULL)
				{
					if( StringTool.SameNoCase(temp_job$.GoalModifier.Go.templatename, bestSpell$.TemplateName ) )
					{
						doit$ = false;
					}
				}
			}		
		
			if( doit$ )
			{
				bestHelper$.Mind.SDoJob( MakeJobReq( JAT_CAST, JQ_ACTION, QP_FRONT, AO_PARTY, weakMember$.Goid, bestSpell$.Goid ) );
				
				// set up the timer to decrement the resurrection charges.
				
				if( heal_recharge$ > 0.0 )
				{
					if( heal_charges_used$ == 0 )
					{
						This.CreateTimer( 3, heal_recharge$ );
						This.SetTimerGlobal( 3, true );
					}
					heal_charges_used$ += 1;
					
//					report.genericf("using: heal_charges_used: %d\n",heal_charges_used$);
					This.SetTimerRepeatCount( 3, heal_charges_used$ );
				} 
				return( true );
			}
		}
		else
		{
			bestHelper$.Mind.SDoJob( MakeJobReq( JAT_CAST, JQ_ACTION, QP_FRONT, AO_PARTY, weakMember$.Goid, bestSpell$.Goid ) );
			return( true );
		}
	}
	else
	{
		report.reportf( "aiskrit", "'%s' - failed to find best helper to heal with\n", m_Go$.TemplateName );
	}

	return false;
}

////////////////////////////////////////
//	function TryChannelMana
//	Use the party members specified to try to channel mana to a friend

bool TryChannelMana$( GopColl Chanelling_members$ )
{
	m_Party$.TempGopCollB.Clear();
	m_Party$.TempGopCollC.Clear();
	
	if ( AIQuery.GetMin( m_Go$, QT_MANA_LOW, m_Go$.Children, m_Party$.TempGopCollB ) )
	{
		////////////////////////////////////////////////////////////////////////////////
		//	help member with low MANA
		Go weakMember$ = m_Party$.TempGopCollB.Get( 0 );
		m_Party$.TempGopCollB.Clear();

		////////////////////////////////////////
		//	find member to cast mana xfer with
		int i$ 		= 0;
		int iend$ 	= Chanelling_members$.Size();

		Go helper$	= NULL;
		Go spell$	= NULL;

		while( i$ != iend$ )
		{
			if( !Chanelling_members$.Get( i$ ).Mind.ActorAutoXfersMana )
			{
				i$ += 1;
				continue;
			}
			helper$ = Chanelling_members$.Get( i$ );

			////////////////////////////////////////
			//	eliminate candidate who is already transferring mana
			if( helper$.Inventory.IsSpellInProgress( "spell_mana_channel" ) )
			{
				i$ += 1;
				continue;
			}

			////////////////////////////////////////
			//	look for mana xfer spell in inventory
			if( !helper$.Mind.GetAutoItems( QT_SPELL, m_Party$.TempGopCollC ) )
			{
				i$ += 1;
				continue;
			}

			int j$ 		= 0;
			int jend$	= m_Party$.TempGopCollC.Size();

			while( j$ != jend$ )
			{
				if( m_Party$.TempGopCollC.Get(j$).TemplateName == "spell_mana_channel" )	// $$$ is this comparison allowed in Skrit?
				{
					// candidate must have enough mana for spell to be cast
					if( spell$.Magic.ManaCost < helper$.Aspect.CurrentMana )
					{
						spell$ = m_Party$.TempGopCollC.Get(j$);
						break;
					}
				}
				j$ += 1;
			}

			if( helper$ && spell$ )
			{
				break;
			}

			i$ += 1;
		}

		////////////////////////////////////////
		//	cast mana xfer spell
		
		if( helper$ && spell$ )
		{
			helper$.Mind.SDoJob( MakeJobReq( JAT_CAST, JQ_ACTION, QP_FRONT, AO_PARTY, helper$.Goid, spell$.Goid ) );
			return( true );
		}
	}
	return false;
}

// JCD 5/21/2003
////////////////////////////////////////
// function TrySupportCreateMonsterList
// this function will create a list of all the monsters which are attacking our party/team
bool TrySupportCreateMonsterList$( GopColl alive_members$ )
{
	// clear out the temp variables we need to create our list
	m_Party$.TempGopCollA.Clear;		// holds the list of attacking monsters upon function return
	m_Party$.TempGopCollB.Clear;		// contains unuseful info upon function return
	m_Party$.TempGopCollC.Clear;		// contains unuseful info upon function return

	// used to determine whether query was succesful
	bool queryResult$;

	
	// TAT 4/22/2003 - what if our teammate is under attack, but not fighting?
	//		Don't change computer behavior
	if (m_Go$.Player.Controller == PC_COMPUTER)
	{
		queryResult$ = AIQuery.Get( m_Go$, QT_FIGHTING, alive_members$, m_Party$.TempGopCollC );
	}
	
	else
	{
		// humans - look for teammates under attack 
		//		checking all alive teammates, not just ALIVE_CONSCIOUS ones 
		//			- if they're unconscious, still want to help

		m_Mind$.TempQtColl1.Clear;
		m_Mind$.TempQtColl1.Add( QT_UNDERATTACK  );
		m_Mind$.TempQtColl1.Add( QT_ALIVE );
		queryResult$ = AIQuery.Get( m_Go$, m_Mind$.TempQtColl1, m_Go$.Children, m_Party$.TempGopCollC );
	}

	// if the query was succesful
	// fill TempGopCollA with monsters which are attacking our party members
	if ( queryResult$ )
	{	
		int ih$ = 0;
		int ihend$ = m_Party$.TempGopCollC.Size();
		Go partyMember$ = NULL;
		// iterate through our attacked players
		while( ih$ != ihend$ )
		{
			// grab an attacked party member
			partyMember$ = m_Party$.TempGopCollC.Get( ih$ );
			// grab party member's attackers and stick them into temp list B
			partyMember$.Mind.GetEngagedMeEnemies(m_Party$.TempGopCollB);

			// add enemies attacking partyMember into temp list A
			int jh$ = 0;
			int jhend$ = m_Party$.TempGopCollB.Size();
			while( jh$ != jhend$ )
			{
				m_Party$.TempGopCollA.Add(m_Party$.TempGopCollB.Get( jh$ ) );	
				jh$ += 1;
			}

			// clear out our temp list which holds attackers
			m_Party$.TempGopCollB.Clear();

			ih$ += 1;
		}
		// if no monsters were found attacking us...
		if( m_Party$.TempGopCollA.Size() < 1 )
		{
			return( false );
		}
	}
	// our query was unsuccesful
	else
	{
		return( false );
	}

	// our list of monsters was succesfully filled
	return( true );
}

////////////////////////////////////////
//	function TrySupport
// JCD 5/21/2003
//	functionality -- 
//  1. create a list of all monsters which are attacking our party/team members
//  2. create a list of all idle party/team members
//  3. iterate idle friends choosing the closest monster for them to attack

bool TrySupport$( GopColl alive_members$ )
{

	// clear out the temp variables we are going to use to create our monster list
	m_Mind$.TempQtColl1.Clear();
	
	// create the list of monsters that are attacking us
	// note : TempGopCollA has needed info in it after TrySupportCreateMonsterList is called and shouldn't be cleared!
	if( !TrySupportCreateMonsterList$(alive_members$) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find monsters attacking our players\n",m_Go$.TemplateName );
		return( false );
	}

	report.reportf( "aiskrit", "'%s' -  found monsters attacking our party\n", m_Go$.TemplateName );

	////////////////////////////////////////
	//	find idle members to help

	// clear out temp variables which we need to use
	m_Mind$.TempQtColl1.Clear;
	m_Party$.TempGopCollB.Clear;	// will contain all idle concious party members

	m_Mind$.TempQtColl1.Add( QT_IDLE  );
	m_Mind$.TempQtColl1.Add( QT_ALIVE_CONSCIOUS );
	
	if( !AIQuery.Get( m_Go$, m_Mind$.TempQtColl1, m_Go$.Children, m_Party$.TempGopCollB ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find idle member\n",m_Go$.TemplateName );
		return( false );
	}

	Go helper$ = NULL;
	bool helped$ = false;
	int ih$ = 0;
	int ihend$ = m_Party$.TempGopCollB.Size();

	report.reportf( "aiskrit", "'%s' - picking helpers\n",m_Go$.TemplateName );

	///////////////////////////////////////
	// try to get everyone to help out based on movement orders.
	
	bool followMode$ = false;
	#only( game )
	[[
		followMode$ = UIPartyManager.FollowMode;
	]]
	
	// iterate through our idle alive concious party members
	while( ih$ != ihend$ )
	{
		helper$ = m_Party$.TempGopCollB.Get( ih$ );

		// check to see if this party member wants to help 

		if( !helper$.Mind.ActorAutoDefendsOthers		|| 
		    ( helper$.Mind.MovementOrders == MO_HOLD )  ||	// must have -- move freely or engage for movement
			!( helper$.Mind.CombatOrders == CO_FREE )   ||	// must have -- attack freely for combat
			( helper$.Inventory.IsPackOnly() == TRUE ) )	// if pack animal -- don't help
		{
			ih$ += 1;
			continue;
		}

		// must have -- melee/ranged weapon, or offensive spell
		// just check for spell since other options are acceptable
		if( helper$.Inventory.IsSpellSelected )
		{
			if( !helper$.Inventory.SelectedSpell.GetMagic().IsOffensive() )
			{
				ih$ += 1;
				continue;
			}
		}

		// choose which enemy this helper should attack based off of proximity
		Go focusEnemy$;
		// TAT - use new func for humans
		if (m_Go$.Player.Controller == PC_COMPUTER)
		{
			focusEnemy$ = helper$.Mind.GetBestFocusEnemy(); 
		}
		else
		{
			// this will find the best enemy from the previously filled list
			#only( game )
			[[
			focusEnemy$ = helper$.Mind.GetBestSupportEnemy(m_Party$.TempGopCollA);
			]]
		}
		


		if( focusEnemy$ == NULL )
		{
			report.reportf( "aiskrit", "'%s' -  can't find attacking enemy\n",m_Go$.TemplateName );
			ih$ += 1;
			continue;
		}

		// TAT 4/22/2003 - this checks to make sure the friend is within range before trying to help
		//		we don't really care about range - so I'm taking out the check
		//		NOTE: this might cause a problem if we try to help someone who we can't reach, because
		//		we have none-overlapping frustums

		// still check for computer guys
		if (helper$.Player.Controller == PC_COMPUTER)
		{
			// can we see the action?
			if ( !followMode$ && ( helper$.Mind.SightRange < helper$.Mind.GetDistance( focusEnemy$ ) ) )
			{
				report.reportf( "aiskrit", "'%s' -  wanted to help but wasn't close enough.\n",m_Go$.TemplateName );
				ih$ += 1;
				continue;
			}
		}

		// JCD 5/4/03
		// @TODO we may want to add a check here to see whether helper can path to focus enemy

		
		if( focusEnemy$ != NULL && helper$ != NULL )
		{

			// if helper is not melee we may have to move within range instead of just giving attack command
			if( helper$.Inventory.IsRangedWeaponSelected || helper$.Inventory.IsSpellSelected )
			{
				// if we have LOS just give job JAT_ATTACK_OBJECT instead of JAT_APPROACH
				if( helper$.Mind.IsLosClear(focusEnemy$) )
				{
					report.reportf( "aiskrit", "'%s' -  %s is helping a friend under attack (2).\n",m_Go$.TemplateName, helper$.TemplateName );
					helper$.Mind.SDoJob( MakeJobReq( JAT_ATTACK_OBJECT, JQ_ACTION, QP_FRONT, AO_PARTY, focusEnemy$.Goid ) );
				}
				// if we don't have LOS then we are going to need to move to a closer range
				else
				{
					report.reportf( "aiskrit", "'%s' - %s is moving to an enemy attacking a friend.\n", m_Go$.TemplateName, helper$.TemplateName );
					helper$.Mind.RSApproach(focusEnemy$, 3, QP_FRONT, AO_PARTY, false);
				}
			}
			// otherwise we are melee, so just give the attack object order
			else
			{
				report.reportf( "aiskrit", "'%s' -  %s is helping a friend under attack (1).\n",m_Go$.TemplateName, helper$.TemplateName );
				helper$.Mind.SDoJob( MakeJobReq( JAT_ATTACK_OBJECT, JQ_ACTION, QP_FRONT, AO_PARTY, focusEnemy$.Goid ) );
			}
			helped$ = true;
			ih$ += 1;
			continue;
		}

		ih$ += 1;
	}
	return helped$;
}

////////////////////////////////////////
//	function TryAttack
//	make everyone in the party attack.

bool TryAttack$()
{
	m_Party$.TempGopCollA.Clear;
	
	////////////////////////////////////////
	//	find idle members to help
	m_Mind$.TempQtColl1.Clear;
	m_Mind$.TempQtColl1.Add( QT_IDLE  );
	m_Mind$.TempQtColl1.Add( QT_ALIVE_CONSCIOUS );
	
	if( !AIQuery.Get( m_Go$, m_Mind$.TempQtColl1, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find idle member\n",m_Go$.TemplateName );
		return( false );
	}

	bool attacked$ = false;
	int ih$ = 0;
	int ihend$ = m_Party$.TempGopCollA.Size();
	Go attacker$ = NULL;
	Go toughestEnemy$;
	
	////////////////////////////////////////
	//	pick a good default enemy for us to attack if we can't see any.
	if( ihend$ > 0 )
	{
		toughestEnemy$ = GetToughestEnemy$( m_Party$.TempGopCollA.Get( 0 ) );
	} 
	
	if( toughestEnemy$ == NULL )
	{
		return( false );
	}

	report.reportf( "aiskrit", "'%s' - picking attackers\n",m_Go$.TemplateName );
	
	///////////////////////////////////////
	// try to get everyone to help out based on movement orders.

	while( ih$ != ihend$ )
	{
		// check to see if this party member wants to help
		if( m_Mind$.MovementOrders != MO_FREE )
		{
			ih$ += 1;
			continue;
		}
		
		attacker$ = m_Party$.TempGopCollA.Get( ih$ );
		
		Go enemy$ = attacker$.mind.GetBestFocusEnemy();
		
		if( enemy$ == NULL )
		{
			enemy$ = toughestEnemy$;
		}
	
		attacker$.Mind.SDoJob( MakeJobReq( JAT_ATTACK_OBJECT, JQ_ACTION, QP_FRONT, AO_PARTY, enemy$.Goid ) );
		attacked$ = true;
		ih$ += 1;
	}
	return attacked$;
}

////////////////////////////////////////
//	function TryFlee
//	make everyone in the party flee.

bool TryFlee$()
{
	m_Party$.TempGopCollA.Clear;
	
	// get alive party members
	if( !AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find alive members\n",m_Go$.TemplateName );
		return false;
	}

	bool fled$ = false;
	int ih$ = 0;
	int ihend$ = m_Party$.TempGopCollA.Size();
	
	///////////////////////////////////////
	// try to get everyone to flee.

	while( ih$ != ihend$ )
	{	
		Go member$ = m_Party$.TempGopCollA.Get( ih$ );
		Go enemy$ = member$.mind.GetBestFocusEnemy();
		
		if( enemy$ == NULL )
		{
			ih$ += 1;
			continue;
		}
	
		fled$ = true;
		member$.Mind.SDoJob( MakeJobReq( JAT_FLEE_FROM_OBJECT, JQ_ACTION, QP_CLEAR, AO_PARTY, enemy$.Goid ) );
		ih$ += 1;
	}
	return fled$;
}

////////////////////////////////////////
//	function FormOnEnemy
//	find an enemy, and take formation facing him.

bool FormOnEnemy$()
{
	report.reportf( "aiskrit", "'%s' -  trying to form up on an enemy\n",m_Go$.TemplateName );
	
	m_Party$.TempGopCollA.Clear;
	
	// get alive party members
	if( !AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find alive members\n",m_Go$.TemplateName );
	} else {
		report.reportf( "aiskrit", "'%s' -  Found %d party members to move\n",m_Go$.TemplateName,m_Party$.TempGopCollA.size );
	}
	
	/// find the lowest ranking member, we want our 
	int i$ = 0,lowest_rank$ = 1000, leader$ = 0;
	int iend$ = m_Party$.TempGopCollA.Size();
	
	while( i$ != iend$ )
	{
		int rank$ = m_Party$.TempGopCollA.Get( i$ ).Mind.Rank;
		if( ( rank$ < lowest_rank$ ) && ( rank$ >= 0 ) )
		{
			lowest_rank$ = rank$;
			leader$ = i$;
		}
		
		i$ += 1;   
	}

	Go member$ = m_Party$.TempGopCollA.Get( leader$ );
	
	member$.Mind.SDoJob( MakeJobReq( JAT_STOP, JQ_ACTION, QP_CLEAR, AO_PARTY ));
	
	////////////////////////////////////////
	//	pick best enemy for leader to form up on.
	
	Go toughestEnemy$ = GetToughestEnemy$( member$ );
	
	if( toughestEnemy$ == NULL )
	{
		report.reportf( "aiskrit", "'%s' -  can't find a good enemy\n",m_Go$.TemplateName );
		return false;
	}
	
	GetSiegeDifference( m_Go$.Party.Formation.Direction, member$.placement.position, toughestEnemy$.placement.position );
	MoveFormation$( member$.placement.position );
	
	if( formation_recharge$ > 0.0 )
	{
		if( formation_charges_used$ == 0 )
		{
			This.CreateTimer( 2, formation_recharge$ );
			This.SetTimerGlobal( 2, true );
		}
		formation_charges_used$ += 1;
		This.SetTimerRepeatCount( 2, formation_charges_used$ ); 
	}
	return( true );
}


////////////////////////////////////////  
//	function ApproachEnemy
//	find an enemy, and approach him in formation.

bool ApproachEnemy$()
{
	report.reportf( "aiskrit", "'%s' -  trying to approach an enemy\n",m_Go$.TemplateName );
	
	m_Party$.TempGopCollA.Clear;
	
	// get alive party members
	if( !AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find alive members\n",m_Go$.TemplateName );
	}
	
	/// find the lowest ranking member, we want our 
	int i$ = 0,lowest_rank$ = 1000, leader$ = 0;
	int iend$ = m_Party$.TempGopCollA.Size();
	
	while( i$ != iend$ )
	{
		int rank$ = m_Party$.TempGopCollA.Get( i$ ).Mind.Rank;
		if( ( rank$ < lowest_rank$ ) && ( rank$ >= 0 ) )
		{
			lowest_rank$ = rank$;
			leader$ = i$;
		}
		
		i$ += 1;   
	}

	Go member$ = m_Party$.TempGopCollA.Get( leader$ );
	
	////////////////////////////////////////
	//	pick best enemy for leader to form up on.
	
	Go toughestEnemy$ = GetToughestEnemy$( member$ );

	if( toughestEnemy$ == NULL )
	{
		report.reportf( "aiskrit", "'%s' -  can't find a good enemy\n",m_Go$.TemplateName );
		return false;
	}
	
	float distance$ = AIQuery.GetDistance( member$.Placement.Position, toughestEnemy$.Placement.Position );
	
	if( melee_ranked$ && !move_freely$ )
	{
		if ( ( distance$ < melee_approach_distance$ ) || ( distance$ < approach_distance$ ) )
		{
			return false;	
		}
	}
	else if ( ( distance$ < min_approach_distance$ ) || ( distance$ < approach_distance$ ) )
	{
		if( move_melee_in_formation$ )
		{
			RankMelee$();
		}
		return false;	
	}
	
	SiegePos TempPos$;
	TempPos$ = member$.placement.position;
	
	if( AIQuery.FindSpotRelativeToSource(	member$,
									toughestEnemy$,
									false,
									approach_distance$ * 0.75,
									approach_distance$ * 1.25,
									10,
									10,
									approach_distance$ * 2.0,
									member$.mind.TempPos1,
									false ) )
	{
		TempPos$ = member$.mind.TempPos1; 
	} else {
		report.generic("couldn't find spot!\n");
		member$.Mind.SDoJob( MakeJobReq( JAT_STOP, JQ_ACTION, QP_CLEAR, AO_PARTY ));
	}
	
	GetSiegeDifference( m_Go$.Party.Formation.Direction, TempPos$, toughestEnemy$.placement.position );
	MoveFormation$( TempPos$ );
	
	if( formation_recharge$ > 0.0 )
	{
		if( formation_charges_used$ == 0 )
		{
			This.CreateTimer( 2, formation_recharge$ );
			This.SetTimerGlobal( 2, true );
		}
		formation_charges_used$ += 1;
		This.SetTimerRepeatCount( 2, formation_charges_used$ ); 
	}
	return( true );
}

////////////////////////////////////////
//	function ThinkDefense
bool ThinkDefense$()
{
	m_Party$.TempGopCollA.Clear();
	m_Party$.TempGopCollB.Clear();
	m_Party$.TempGopCollC.Clear();

	if( m_Go$.Children.Size < 2 )
	{
		return( false );
	}

	report.report( "aiskrit", "ThinkDefense$\n" );

	////////////////////////////////////////
	// Actions we will give to busy party members.
	
	////////////////////////////////////////
	// Try to heal buddy.
	
	if( ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER ) )
	{
//		report.genericf(" HCU: %d, HC: %d\n",heal_charges_used$,heal_charges$ );
		
		if( ( Math.RandomFloat( 1 ) < heal$ ) && ( heal_charges_used$ < heal_charges$ ) )
		{
			if( TryHeal$( m_Go$.Children, false ) )
			{
				return true;
			}
		}	
	}
		
	////////////////////////////////////////
	// Try to resurrect buddy.
	
	if( ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER ) )
	{
		if( ( Math.RandomFloat( 1 ) < reanimate$ ) && ( reanimate_charges_used$ < reanimate_charges$ ) )
		{
			if( TryResurrect$( m_Go$.Children ) )
			{
				return true;
			}
		}	
	}
		
	////////////////////////////////////////
	// Actions we will give to idle party members.
	
	////////////////////////////////////////
	//	find IDLE members to help
	m_Mind$.TempQtColl1.Clear;
	m_Mind$.TempQtColl1.Add( QT_IDLE  );
	m_Mind$.TempQtColl1.Add( QT_ALIVE_CONSCIOUS );
	
	if( !AIQuery.Get( m_Go$, m_Mind$.TempQtColl1, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		return( false );
	}

	if( m_Go$.Children.Get( 0 ).Player.Controller == PC_HUMAN )
	{ 
		// heal conscious party members
		if( TryHeal$( m_Party$.TempGopCollA, false ) )
		{
			return true;
		}
		
		// heal unconscious party members
		if( TryHeal$( m_Party$.TempGopCollA, true ) )
		{
			return true;
		}
	}
	
	if( TryChannelMana$( m_Party$.TempGopCollA ) )
	{
		return true;
	}
	
	////////////////////////////////////////
	//	catch-all: took no action
	return( false );
}


////////////////////////////////////////
//	function ThinkOffense
bool ThinkOffense$()
{
	if( m_Go$.Children.Size < 2 )
	{
		return( false );
	}

	report.report( "aiskrit", "ThinkOffense$\n" );

	m_Party$.TempGopCollA.Clear;
	
	////////////////////////////////////////
	//	check the living
	if( !AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA ) )
	{
		report.reportf( "aiskrit", "'%s' -  can't find alive members\n",m_Go$.TemplateName );
		return( false );
	}
	
	num_alive_members_in_party$ = m_Party$.TempGopCollA.size;
	
	if( ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER ) && ( num_ranked$ > 0 ) )
	{
		if( formation_charges_used$ < formation_charges$ )
		{
			if( ( required_members_for_all_out_attack$ >= 0 ) || ( required_alive_members_for_all_out_attack$ >= 0 ) )
			{
				if( ( ( required_members_for_all_out_attack$ >= 0 ) && ( m_Go$.Children.size >= required_members_for_all_out_attack$ ) ) || ( ( num_alive_members_in_party$ >= required_alive_members_for_all_out_attack$ ) && ( required_alive_members_for_all_out_attack$ >= 0 ) ) )
				{
					if( TryAttack$() )
					{
						report.reportf( "aiskrit", "'%s' -  trying all out attack, I have %d guys, and I need %d\n",m_Go$.TemplateName,m_Go$.Children.size,required_members_for_all_out_attack$ );
						return true;
					}
				}
			}
			
			if ( !move_freely$ )
			{
				if( num_ranged_attackers_in_party$ >= required_ranged_attackers_to_hold_ground$ )
				{
					if( FormOnEnemy$() )
					{
						report.reportf( "aiskrit", "'%s' -  trying to hold, I have %d ranged guys, and I need %d\n",m_Go$.TemplateName,num_ranged_attackers_in_party$,required_ranged_attackers_to_hold_ground$ );
						return true;
					}
				}
				
				if( num_ranged_attackers_in_party$ >= required_ranged_attackers_to_hold_formation$ )
				{
					if( ApproachEnemy$() )
					{
						report.reportf( "aiskrit", "'%s' -  trying to approach, I have %d ranged guys, and I need %d\n",m_Go$.TemplateName,num_ranged_attackers_in_party$,required_ranged_attackers_to_hold_formation$);
						return true;
					}
				}
			}
			
			if( move_ranged_in_formation$ && ( num_ranged_attackers_in_party$ >= required_ranged_attackers_to_hold_formation$ ) && ( num_alive_members_in_party$ >= required_party_members_to_hold_formation$ ) )
			{
				if( ApproachEnemy$() )
				{
					report.reportf( "aiskrit", "'%s' -  trying to approach, I have %d ranged guys, and I need %d\n",m_Go$.TemplateName,num_ranged_attackers_in_party$,required_ranged_attackers_to_hold_formation$);
					return true;
				}
			}
		}
	}
	
	m_Party$.TempGopCollA.Clear;
	AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA );
	if( TrySupport$( m_Party$.TempGopCollA ) )
	{
		return true;
	}

	return( false );
}

/*
// JCD
////////////////////////////////////////
//	function GetEnemyAttackingAlly
//	returns an enemy that is attacking an ally

Go  GetEnemyAttackingAlly$()
{
	Go temp$ = NULL;
	if( num_alive_members_in_party$ > 0 )
	{
		// fill the collection with all alive friends
		AIQuery.Get( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children, m_Party$.TempGopCollA );

		int ih$ = 0;
		int ihend$ = m_Party$.TempGopCollA.Size();

		while( ih$ != ihend$ )
		{
			Go partyMember$ = m_Party$.TempGopCollA.Get( ih$ );
			m_Mind$.TempGopColl1.Clear;
			partyMember$.Mind.GetEngagedMeEnemies( m_Mind$.TempGopColl1 );
			int i$ = 0;
			int iend$ = m_Mind$.TempGopColl1.size;
			while( i$ < iend$ )
			{
				if( temp$ == NULL )
				{
					temp$ = m_Mind$.TempGopColl1.Get( i$ );
				}
				if( partyMember$.Mind.IsFriend(temp$) )
				{
					temp$ = NULL;
				}
				i$ = i$ + 1;
			}
			ih$ = ih$ + 1;
		}
	}
	return temp$;
}
*/

/////////////////////
// Certain actions can only happen a few times before they need to recharge, Timer 1 corresponds to resurection.

/////////////////////
// Resurrection recharge

Trigger OnTimer$( 1 )
{
	reanimate_charges_used$ -= 1;
	if( reanimate_charges_used$ < 0)
	{
		Report.generic("Error: Miscalculation of remaining resurrection charges.\n");
	}
}

/////////////////////
// Formation recharge

Trigger OnTimer$( 2 )
{
	formation_charges_used$ -= 1;
	if( formation_charges_used$ < 0)
	{
		Report.generic("Error: Miscalculation of remaining formation charges.\n");
	}
}

/////////////////////
// Heal recharge

Trigger OnTimer$( 3 )
{
	heal_charges_used$ -= 1;
	if( heal_charges_used$ < 0)
	{
		report.genericf("heal_charges_used: %d\n",heal_charges_used$);
		Report.generic("Error: Miscalculation of remaining heal charges.\n");
	}
}

/////////////////////
// Battle Time
// This is done to assure that our enemies aren't hitting us too much with ranged attacks that we can't respond to.

Trigger OnTimer$( 10 )
{
//	report.generic("I don't think I'm in combat anymore.\n");
	in_combat$ = false;
}

Trigger OnTimer$( 11 )
{
	if( in_combat$ )
	{
//		report.generic("wasn't able to fight back, charge!!\n");
		FreeMovement$();
		TryAttack$();
	}
}


////////////////////////////////////////////////////////////////////////////////
//	main state machine
state Thinking$
{
	float update$ = 0.1;

	/*
	// JCD
	trigger OnTimer$( 15 )
	{
		// $$$ temp
		Report.Genericf( "Hit Jay's timer for %s\n", m_Go$.TemplateName );
		This.CreateTimer( 15 , 4 );

		// TAT - only do this if we're idle
		if ( !m_Mind$.AmBusy() )
		{
			Report.Genericf( "Idle for %s\n", m_Go$.TemplateName);

			Go enemyTarget$;
			enemyTarget$ = GetEnemyAttackingAlly$();
			if( enemyTarget$ != NULL )
			{
				// $$$ temp
				Report.Genericf( "Found an enemy - %s -  for %s\n", enemyTarget$.TemplateName, m_Go$.TemplateName );
				//m_Mind$.SDoJob( MakeJobReq( JAT_ATTACK_OBJECT, JQ_ACTION, QP_FRONT, AO_PARTY, enemyTarget$.Goid ) );
			}
		}
	}
	*/
	
	////////////////////////////////////////
	//	process messages sent to party members

	event OnCCWorldMessage$( eWorldEvent e$, WorldMessage msg$ )
	{
		if(  m_Go$.Children.Size > 0 )
		{
			if(  m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER )
			{
				if( e$ == WE_MANA_RATIO_REACHED_LOW )
				{
					Go Low$ = msg$.GetSendTo().Go;
					
					Low$.Mind.RSSetCombatOrders( CO_FREE );
					Low$.Mind.RSSetMovementOrders( MO_LIMITED );
				} 
				else  if( e$ == WE_LIFE_RATIO_REACHED_LOW )
				{
					if( !move_freely$ && free_move_on_life_low$ )
					{
						FreeMovement$();
					}
				}
				else if( e$ == WE_KILLED )
				{
					if( flee_when_member_killed$ )
					{
						TryFlee$();
					}
					party_dirty$ = true;
				}
				else if( e$ == WE_RESURRECTED )
				{
					party_dirty$ = true;
				}
				else if( e$ == WE_ENEMY_ENTERED_INNER_COMFORT_ZONE )
				{
					if( !move_freely$ && free_move_on_enemy_enter_ICZ$ )
					{
						FreeMovement$();
					}
				}
				else if( e$ == WE_ENEMY_ENTERED_OUTER_COMFORT_ZONE )
				{
					if( !move_freely$ && free_move_on_enemy_enter_OCZ$ )
					{
						FreeMovement$();
					}
				}
				
				// to make sure that we aren't getting hit from outside our range. Checking to see that we get to attack every once in a while
				// otherwise we will free movement so the player can't take advantage of the mosters staying in formation.
				
				else if( e$ == WE_DAMAGED )  
				{
					if( free_move_if_cant_respond$ )
					{
						if( !move_freely$ && ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER ) )
						{	
							if( in_combat$ )
							{
								This.CreateTimer( 10, 8); // we are in combat for eight seconds after we are hit.
								This.SetTimerGlobal( 10, true );
							} else {
								This.CreateTimer( 10, 8); // we aren't effective at fighting if we haven't been able to attack for at least 10 seconds and we are still in combat.
								This.SetTimerGlobal( 10, true );
								This.CreateTimer( 11, 10);
								This.SetTimerGlobal( 11, true );
								in_combat$ = true;
							}
						}
					}
				}
				else if( e$ == WE_ANIM_WEAPON_FIRE )
				{
					if( free_move_if_cant_respond$ )
					{
						if( in_combat$ && !move_freely$ && ( m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER ) )
						{
							This.CreateTimer( 11, 10); // we aren't effective at fighting if we haven't been able to attack for at least 10 seconds and we are still in combat.
						}
					}
				}
			}
		}
	}

/*	////////////////////////////////////////
	//	process messages sent to party

	event OnWorldMessage$( eWorldEvent e$, WorldMessage msg$ )
	{
	}
*/
	trigger OnWorldMessage$( WE_JOB_TIMER_DONE )
	{
		m_Job$.SetTimer( m_Mind$.SensorScanPeriod );
		
		if( m_Go$.Children.Size > 0 )
		{
			if(  m_Go$.Children.Get( 0 ).Player.Controller == PC_COMPUTER )
			{
				// check to see if we have any alive members, if not get rid of the party.
				if( AIQuery.GetCount( m_Go$, QT_ALIVE_CONSCIOUS, m_Go$.Children ) == 0 )
				{
					GoDb.SMarkForDeletion( m_Go$.goid );
					return;
				} 
				else
				{
					// check to see if anyone added themselves to our party.
					int new_memebers$ = m_Go$.Children.Size();
					if( new_memebers$ != num_memebers$ )
					{
						num_memebers$ = new_memebers$;
						party_dirty$ = true;
					}
					
					if( party_dirty$ )
					{
						party_dirty$ = false;
						if( rank_members$ )
						{
							InitParty$();
						}
			 		}
				}
			}

			update$ = ( update$ > ( 6 * m_Mind$.SensorScanPeriod ) ) ? update$ : ( update$ + m_Mind$.SensorScanPeriod );

			if( ThinkDefense$() )
			{
				update$ = m_Mind$.SensorScanPeriod;
			}
			if( ThinkOffense$() )
			{
				update$ = m_Mind$.SensorScanPeriod;
			}
			
//			report.genericf("update: %g\n", update$);
			m_Job$.SetTimer( update$ );

		}
		else if ( m_Party$.WaitingToJoinCount == 0 )
		{
			GoDb.SMarkForDeletion( m_Go$.goid );
		}
	}
	
	event OnEnterState$
	{
		update$ = m_Mind$.SensorScanPeriod;
		m_Job$.SetTimer( m_Mind$.SensorScanPeriod );

		/*
		// TAT - only create this timer for humans
		if (m_Go$.Children.Get( 0 ).Player.Controller != PC_COMPUTER)
		{
			This.CreateTimer( 15 , 5 );	// JCD
		}
		*/
	}
}